1.  Plan First 체크리스트본격적인 개발 착수 전, 아래 6가지 항목을 우선 검토하고 충족해야 합니다.[ ] 카카오 정책 검증: 카카오 OAuth 2.0 정책 [Report, cite: 4], Biz Message API (알림톡/친구톡) 가이드라인 및 template*object 스펙을 확인합니다. [Report, cite: 1, 9][ ] 보안 모델 검토: Supabase Auth (GoTrue)의 JWT 흐름과 Postgres의 RLS(Row Level Security) 정책을 검토하고 확정합니다. [Report, cite: 2, 3][ ] 개인정보보호 정책 수립: 수집하는 PII(이메일, OAuth 토큰) 항목을 최소화하고, 이에 대한 보존/파기 정책을 포함한 '개인정보 처리방침' 초안을 작성합니다.[ ] MVP 기능 범위 확정: 섹션 3의 MoSCoW 우선순위에 따라 MVP(Must, Should) 범위를 확정합니다.[ ] 핵심 리스크 대응: 최우선 리스크(카카오 정책 변경, 토큰 탈취)에 대한 완화 방안(섹션 10)을 수립합니다.[ ] 확장성 설계: [Report]에서 제안한 Slack/Google Forms 연동 [Report, cite: 7, 8]을 고려하여, 섹션 11의 Provider 추상화 인터페이스 설계를 검토합니다.2. 제품 개요페르소나 (Persona): 1인 기업가, 마케터, 소규모 쇼핑몰 운영자 (비개발자 또는 초급 개발자).핵심 과업 (Job-to-be-Done): "고객에게 주문/배송 확인 알림톡을 보내기 위해, 복잡한 개발 설정(OAuth, JSON) 없이 카카오 채널을 내 서비스에 연결하고, 템플릿을 만들어 테스트 발송을 완료한다."가치 제안 (Value Proposition): "개발 지식 없이 10분 안에 카카오톡 메시지 연동부터 테스트 발송까지 완료하세요. 복잡한 OAuth와 JSON 템플릿은 저희가 대신 처리해 드립니다."성공 지표 (Metrics):North Star: 주간 활성 커넥션 수 (WAU - Weekly Active Connections. 앱에 연결되어 최소 1회 이상 메시지 전송/테스트를 수행한 카카오 채널 수)선행 지표:연결 완성률: (OAuth 시작 대비 → 채널 연결 성공 비율) [Report]첫 전송까지 시간 (Time-to-First-Send): (회원가입 완료 → 첫 테스트 메시지 발송 성공까지 소요 시간)테스트 성공률: (총 테스트 시도 대비 → 성공 비율) [Report]3. 기능 구조 (MVP vs. 확장)[Report]의 기능 모듈 [Report]을 기반으로 MoSCoW 우선순위를 적용하여 MVP 범위를 설정합니다.기능명사용자 스토리 (As a user, I want to...)우선순위의존성성공지표출시단계인증이메일/소셜 로그인으로 가입/로그인 [Report]Must-회원가입 전환율MVP채널 연결카카오 계정으로 로그인해 내 채널을 앱에 연결 [Report]Must인증연결 완성률MVP템플릿 편집UI 편집기로 알림톡/친구톡 템플릿 생성 [Report]Must채널 연결템플릿 생성 수MVP실시간 미리보기템플릿 작성 시 JSON과 미리보기 확인 [Report]Must템플릿 편집-MVP전송 테스트생성한 템플릿으로 실제 메시지 발송 테스트 [Report]Must템플릿 편집첫 전송까지 시간MVP에러 진단전송 실패 시, 쉬운 한글 설명으로 원인 파악 [Report, cite: 6, 9]Must전송 테스트테스트 성공률MVP코드 생성기템플릿에 맞는 curl 코드를 복사 [Report, cite: 5]Should템플릿 편집코드 복사 횟수MVP전송 로그과거 전송 성공/실패 이력 조회 [Report]Should전송 테스트-MVP템플릿 관리생성한 템플릿 목록 조회/수정/삭제 [Report]Should템플릿 편집-MVPSlack 연동카카오 외 Slack 채널도 연결 [Report, cite: 7]Could-신규 플랫폼 연결 수확장Google Forms 연동구글 폼 응답 시 메시지 발송 [Report, cite: 8]Could-신규 플랫폼 연결 수확장팀/권한 관리여러 사용자가 한 채널을 공동 관리Won't인증-확장4. 기술 스펙[Report]의 '테크 스펙'을 기반으로 구체화합니다.🛰️ 프론트엔드프레임워크: React + Vite [Report]라우팅: React Router [Report]상태 관리: React Context API 또는 Zustand (경량 상태 관리) [Report]UI/스타일링: Tailwind CSS [Report]폼·검증: React Hook Form (템플릿 편집기 등 복잡한 폼 검증용)연동 라이브러리: @supabase/supabase-js [Report, cite: 10]보안 헤더: 배포 플랫폼(Vercel/Netlify)에서 CSP, HSTS 등 기본 보안 헤더 설정.⚙️ 백엔드언어/프레임워크: Node.js + TypeScript (Express 또는 NestJS) [Report]인증 계층:클라이언트 → 백엔드: Supabase JWT (GoTrue) 검증 [Report, cite: 2]백엔드 → 카카오: DB에 저장된 사용자별 OAuth Access Token 사용 [Report]토큰 관리 (Kakao):암호화 저장: Access/Refresh 토큰은 **Supabase의 pgsodium**을 사용해 DB 내에서 암호화. [Report] (암호화 언급)회전/만료: 토큰 만료 에러(예: code: -401 [Report, cite: 9]) 수신 시, 사용자에게 재인증(OAuth) 요청 알림. (Biz Message API의 Refresh Token 지원 여부 불확실 [Report, cite: 4])레이트리밋:인바운드 (Client → BE): express-rate-limit (IP/사용자 기준 요청 제한)아웃바운드 (BE → Kakao): p-queue (카카오 API의 TPS 제한 준수)API: [Report]의 API 구조(예: POST /api/send-test)를 따름. [Report]🗃️ 데이터[Report]의 데이터 구조 [Report]에 PII 및 보존 정책을 추가합니다.엔티티 (테이블명)주요 필드PII 여부보존기간인덱스관계Users [Report]id (UUID), email, created_at, auth_user_idYes (email)회원 탈퇴 시 30일 유예 후 파기auth_user_id-Connections (채널)id, user_id, provider (kakao), channel_id, access_token (암호화), expires_inYes (token)연결 해제 시 즉시 파기user_idUsers (1:N)Templates [Report]id, user_id, name, type (알림톡/친구톡), template_object (JSONB)No영구 (사용자 삭제 전까지)user_idUsers (1:N)SendLogs [Report]id, user_id, template_id, sent_at, status (success/fail), error_code, error_msgNo1년user_id, sent_atUsers (1:N)AuditLogsid, user_id, action (e.g., 'connect_channel'), timestampNo1년user_id, timestampUsers (1:N)🏗️ 인프라호스팅 (FE): Vercel 또는 Netlify (Vite 정적 빌드) [Report]호스팅 (BE/DB): Supabase (Managed Postgres, Auth, Edge Functions) [Report, cite: 12]비밀관리: Supabase Vault 또는 플랫폼 환경 변수. [Report, cite: 11] (VITE* 접두어 없는 변수)CDN / WAF: Vercel/Supabase 기본 제공.비용 추정 (MVP, 월): Supabase Pro Plan ($25) + Vercel Pro Plan ($20) = 월 약 $45 (트래픽 미미 가정)🔒 보안OAuth: Authorization Code Grant + PKCE (Public Client이므로 필수)CSRF: OAuth state 파라미터 사용.DB 보안: 모든 테이블에 Supabase RLS (Row Level Security) 활성화. (예: Templates는 auth.uid() = user_id인 경우에만 접근 허용) [Report, cite: 3]네트워크: HTTPS 강제, OAuth Redirect URI는 https://만 허용. [Report]감사: 주요 행위 (채널 연결, 토큰 갱신)는 AuditLogs에 기록.📊 품질테스트 전략:Unit (Vitest): 템플릿 JSON 생성 로직, 에러 코드 매핑 함수.E2E (Cypress): 회원가입 → 채널 연결 → 템플릿 생성 → 테스트 발송 (Mock Kakao API)배포: Vercel/Netlify Git 연동 (Main 브랜치 Push 시 자동 배포) [Report]옵저버빌리티:SLO (목표): 99.9% Uptime, API P95 Latency < 500ms.알람: Supabase 로그 기반 알람 (e.g., 5분 내 5xx 에러 > 10회)결정·근거·다음 단계:결정: **Supabase (Pro Plan) + Vercel (Pro Plan)**을 MVP 스택으로 확정.근거: [Report]에서 제안한 스택이며 [Report], 소규모 팀이 BE/DB/Auth/FE 호스팅을 빠르게 해결하고 RLS로 강력한 보안을 적용하기에 가장 효율적입니다. [Report, cite: 3, 10, 15]다음 단계: Supabase 프로젝트 생성 및 위 '데이터' 섹션의 스키마 적용. Vercel/Netlify에 Vite 스타터 프로젝트 연결.5. OAuth2 연결 설계 (Kakao)플로우: Authorization Code Grant + PKCE스코프 (가정): talk_message (메시지 전송), kakaotalk_channel (채널 정보). ([주의: Biz Message API [Report, cite: 4]는 일반 REST API [Report, cite: 1]와 OAuth 흐름이 다를 수 있음. [Report]의 제안을 따라 표준 OAuth 흐름으로 설계.])보안·오류:CSRF 방지: state 파라미터를 생성하여 세션/쿠키에 저장 후 콜백 시 비교.토큰 탈취 방지 (PKCE): (FE) code_verifier 생성 → code_challenge (SHA256) 계산 → (BE) code_verifier와 함께 토큰 요청.오류 처리: 콜백 URL에 error=access_denied 등 수신 시 사용자에게 안내.🌊 OAuth2 시퀀스 다이어그램 (Text-based)코드 스니펫sequenceDiagram
    participant User
    participant FE (React App)
    participant BE (Supabase/Vercel Fn)
    participant KakaoAuth

        User->>FE: 1. '카카오 채널 연결' 클릭
        FE->>FE: 2. PKCE code_verifier, state 생성 (세션/쿠키 저장)
        FE->>User: 3. KakaoAuth로 리다이렉트 (client_id, redirect_uri, state, code_challenge)
        User->>KakaoAuth: 4. 카카오 로그인 및 스코프 동의
        KakaoAuth->>User: 5. FE의 callback URI로 리다이렉트 (code, state)
        User->>FE: 6. /auth/kakao/callback 접속 (code, state 전달)

        FE->>FE: 7. 저장된 state와 콜백 state 비교 (CSRF 검증)
        FE->>BE: 8. POST /api/kakao/connect (code, code_verifier)

        BE->>KakaoAuth: 9. POST /oauth/token (토큰 요청) (client_id, client_secret, redirect_uri, code, code_verifier)
        KakaoAuth-->>BE: 10. Access Token, Refresh Token, expires_in

        BE->>BE: 11. (중요) Access Token 암호화 (pgsodium)
        BE->>BE: 12. DB 'Connections' 테이블에 (user_id, channel_id, encrypted_token) 저장 [Report]
        BE-->>FE: 13. { success: true, channel_name: "..." }
        FE->>User: 14. "채널 연결 성공!" 알림

    결정·근거·다음 단계:결정: PKCE를 포함한 표준 Authorization Code Grant 플로우를 사용.근거: Public Client (SPA) 환경에서 client*secret 노출 없이 토큰을 교환해야 하므로 PKCE가 필수이며, CSRF 방지를 위해 state를 사용해야 합니다.다음 단계: BE에 /api/kakao/connect 엔드포인트 구현 (토큰 교환 및 암호화 저장). FE에 콜백 처리 로직 구현.6. 메시지 전송 템플릿템플릿 스키마: [Report]의 template_object (JSON) 형식을 따릅니다. [Report, cite: 1, 5]검증: FE (React Hook Form) 및 BE (Zod/Joi)에서 2중 검증 (예: object_type, 필수 링크 등)미리보기: [Report]의 제안대로 [Report], 편집기 UI와 미리보기를 연동. JSON 구조를 React 컴포넌트로 실시간 렌더링.버전 관리: MVP에서는 updated_at으로 최신 버전을 관리.1💻 코드 예시21. 프론트엔드: Authorization Code with PKCE 시작 (React)3JavaScript// (utils/pkce.js)
    async function generateCodeChallenge(codeVerifier) {
    const data = new TextEncoder().encode(codeVerifier);
    const digest = await window.crypto.subtle.digest('SHA-256', data);
    return btoa(String.fromCharCode.apply(null, [...new Uint8Array(digest)]))
    .replace(/\+/g, '-')
    .replace(/\//g, '*')
    .replace(/=+$/, '');
    }

// (components/KakaoConnectButton.jsx)
async function handleKakaoLogin() {
const codeVerifier = "RANDOM_STRING_GENERATED_HERE"; // Generate random string
sessionStorage.setItem("code_verifier", codeVerifier);

const codeChallenge = await generateCodeChallenge(codeVerifier);
const state = "RANDOM_STATE_STRING"; // Generate CSRF token
sessionStorage.setItem("oauth_state", state);

const params = new URLSearchParams({
client_id: import.meta.env.VITE_KAKAO_CLIENT_ID, // [Report, cite: 11]
redirect_uri: "https://<app_domain>/auth/kakao/callback",
response_type: "code",
state: state,
code_challenge: codeChallenge,
code_challenge_method: "S256"
});

window.location.href = `https://kauth.kakao.com/oauth/authorize?${params.toString()}`;
} 2. 백엔드: 토큰 교환 및 메시지 전송 프록시 (Node.js/Express)TypeScript// (routes/kakao.js)
// 5. OAuth 콜백 처리
router.post("/api/kakao/connect", async (req, res) => {
const { code, code_verifier } = req.body;
const userId = req.auth.userId; // JWT 미들웨어에서 주입됨

// 9. 토큰 교환
const tokenResponse = await axios.post("https://kauth.kakao.com/oauth/token", new URLSearchParams({
grant_type: "authorization_code",
client_id: process.env.KAKAO_CLIENT_ID,
client_secret: process.env.KAKAO_CLIENT_SECRET, // 백엔드에만 저장 [Report, cite: 11]
redirect_uri: "https://<app_domain>/auth/kakao/callback",
code: code,
code_verifier: code_verifier
}));

const { access_token, expires_in } = tokenResponse.data;

// 11. 토큰 암호화 (pgsodium 사용 예시 - Supabase RPC 호출)
const encryptedToken = await supabase.rpc('encrypt_token', { token: access_token });

// 12. DB 저장
await supabase.from("Connections").insert({
user_id: userId,
provider: "kakao",
access_token: encryptedToken,
expires_in: expires_in
});

res.status(200).json({ success: true });
});

// 6. 메시지 전송 테스트 (API 프록시)
router.post("/api/send-test", async (req, res) => {
const { template_object } = req.body;
const userId = req.auth.userId;

// 1. DB에서 토큰 조회 및 복호화
const { data: conn } = await supabase.from("Connections").select("access_token").eq("user_id", userId).single();
const accessToken = await supabase.rpc('decrypt_token', { token: conn.access_token });

try {
// 2. [Report, cite: 5]에서 언급된 '나에게 보내기' API 호출
const KAKAO_API_URL = "https://kapi.kakao.com/v2/api/talk/memo/default/send";

    const response = await axios.post(
      KAKAO_API_URL,
      new URLSearchParams({ template_object: JSON.stringify(template_object) }), // [Report]
      {
        headers: {
          "Authorization": `Bearer ${accessToken}`, // [Report, cite: 5]
          "Content-Type": "application/x-www-form-urlencoded" // [Report]
        }
      }
    );

    // 3. 성공 로그
    await supabase.from("SendLogs").insert({ user_id: userId, status: "success", ... });
    res.status(200).json({ success: true, data: response.data });

} catch (error) {
// 4. 에러 처리 [Report, cite: 6, 9]
const kakaoError = error.response?.data;
const errorCode = kakaoError?.code; // 예: -502 [Report]
const errorMsg = kakaoError?.msg; // [Report]

    // 5. 실패 로그
    await supabase.from("SendLogs").insert({ user_id: userId, status: "fail", error_code: errorCode, ... });

    // 6. 에러 진단 메시지 반환
    res.status(400).json({
      success: false,
      code: errorCode,
      message: mapKakaoErrorToGuide(errorCode) // -502 -> "수신자가 채널 친구가 아닙니다."
    });

}
});
결정·근거·다음 단계:결정: [Report]의 제안대로 템플릿 UI와 template_object JSON을 1:1 매핑하여 개발합니다. [Report]근거: 카카오 API가 template_object라는 특정 JSON 구조를 요구합니다. [Report, cite: 1]다음 단계: FE에 템플릿 유형(텍스트, 피드 등) [Report]에 따른 동적 폼 빌더 구현. BE에 mapKakaoErrorToGuide 헬퍼 함수 구현 (주요 에러 코드 [Report, cite: 9] 매핑).7. 관리 콘솔 (MVP 범위)연결 상태 대시보드: (MVP) 연결된 카카오 채널 목록 표시. (확장) 토큰 만료 예정일 알림.전송 로그: SendLogs 테이블 조회. (필터: 날짜, 성공/실패, 템플릿 ID) [Report]실패 재시도: (MVP에서는 Won't)키·Webhook 관리: (MVP에서는 Won't)결정·근거·다음 단계:결정: MVP 관리 콘솔은 '연결된 채널 목록'과 '전송 로그 조회' 기능에 집중합니다.근거: [Report]의 MVP 타임라인(1-2주) [Report, cite: 16] (본 계획 6주) 내 핵심 가치(연결, 테스트)에 집중.다음 단계: Supabase RLS가 적용된 SendLogs 테이블을 조회하는 FE 페이지 구현.8. 상업성·요금고객 세그먼트: (섹션 2의 페르소나와 동일)경쟁 벤치마크: 알림톡 발송 대행사 (e.g., NHN, 루나소프트), Zapier/Make (범용 자동화 툴)차별점: '설정'의 간소화. 기존 대행사는 '발송'에 집중, 자동화 툴은 너무 범용적. 본 서비스는 '카카오 연동'이라는 특정 허들(OAuth, 템플릿)을 타겟.가격 모델 (가설):Free (MVP): 1개 채널 연결, 월 100건 테스트 발송.Pro (확장): 월 $10. 채널 3개, 월 10,000건 발송 (실제 발송비 별도), 로그 30일 보관.Business (확장): 월 $50. 채널 무제한, 팀 기능, 감사 로그, 우선 지원.COGS/마진: (매우 낮음) 비용은 Supabase/Vercel 월정액이 전부.주요 지표 (측정):활성화: 연결 완성률, 첫 전송까지 시간 (TTFS) [Report]유지: 주간 활성 커넥션 (WAU), 전송 실패율 [Report]수익 (확장 시): Free → Pro 전환율, ARPA (계정당 평균 수익)결정·근거·다음 단계:결정: MVP는 100% 무료로 제공하여 사용자 확보 및 가설 검증에 집중합니다.근거: 소규모 팀이 초기 수익보다 PMF(Product-Market Fit)를 찾는 것이 중요합니다.다음 단계: GA 또는 Amplitude를 연동하여 '연결 완성률'과 'TTFS' 퍼널 측정.9. 운영·컴플라이언스온보딩·지원: (MVP) Notion 기반의 스크린샷 가이드 문서.상태페이지: (MVP) Vercel/Supabase 기본 상태 페이지 링크.데이터 보존·파기: (섹션 4 데이터 스펙 참조)로그: SendLogs, AuditLogs 1년 보관 후 파기.PII: Users (이메일), Connections (토큰) - 탈퇴/연결 해제 시 즉시 파기.약관: 서비스 이용약관, 개인정보 처리방침 (수집 항목: 이메일, 카카오 채널 정보, 암호화된 토큰 / 이용 목적: 메시지 전송 대행 / 보관 기간 명시) 필수 게시.결정·근거·다음 단계:결정: '개인정보 처리방침'을 MVP 출시 전 반드시 작성하고 웹사이트에 게시합니다.근거: PII(이메일, 토큰)를 수집하므로 법적 필수 사항입니다.다음 단계: 변호사/전문가 검토를 거쳐 개인정보 처리방침 초안 작성.10. 리스크 매트릭스항목설명신호 (Signal)영향 (H)가능성 (M)대응 (Mitigation)백업 (Backup)정책 변경카카오가 OAuth/API 정책 변경 (예: 스코프 축소, 유료화)카카오 개발자 공지높음중간(대응) 공지 즉시 분석, 앱 수정.
(회피) 특정 API에 과도하게 의존 X확장 전략(11) 실행 (네이버/구글로 분산)보안 사고Access Token 탈취 (예: DB 유출, XSS)비정상적 API 호출 급증높음낮음(대응) DB 암호화(pgsodium), RLS [Report, cite: 3], XSS 방지, FE/BE 2중 검증.사고 즉시 해당 사용자 토큰 만료 처리 및 강제 재인증심사 지연알림톡 템플릿 승인 지연 (카카오 소관)-낮음높음(회피) 우리 서비스는 '도구'임. 심사는 사용자 책임임을 명시. [Report]사용자에게 '친구톡'(심사 불필요) 사용 가이드API 장애카카오 API 장애 (5xx)5xx 에러율 급증중간낮음(대응) API 호출 타임아웃/재시도(Exponential Backoff) 구현.서비스 상태페이지에 "카카오 API 장애" 공지비용 폭증Supabase/Vercel 사용량 급증 (예: 악의적 트래픽)Supabase 대시보드 알람중간낮음(대응) BE API 레이트리밋 적용.
(회피) Supabase 사용량 알람 설정.Supabase Spend Cap 설정 (서비스 중단 감수)계정 차단우리 앱이 스팸 발송 앱으로 오인되어 차단 [Report, cite: 9]API 차단 에러높음낮음(회피) 카카오 발송 가이드라인 준수 (광고성 메시지 등).카카오에 즉시 소명.결정·근거·다음 단계:결정: **보안 사고 (토큰 탈취)**와 정책 변경을 최우선 리스크로 관리합니다.근거: 토큰 탈취는 서비스 신뢰도에 치명적이며, 정책 변경은 서비스의 존속을 위협합니다.다음 단계: BE 개발 시 pgsodium을 이용한 토큰 암호화 로직을 최우선 구현. 카카오 개발자 뉴스레터 구독.11. 확장 전략 (Provider Abstraction)[Report]의 Slack/Google Forms [Report, cite: 7, 8] 외 네이버, 구글(FCM) 등 유사 메시징 플랫폼 확장을 고려하여 설계합니다.1. 추상화 계층 (Interface)TypeScript// (예시: /providers/IProvider.ts)
interface IProvider {
providerName: string;
connect(authCode: string, verifier: string): Promise<ConnectionResult>;
send(connection: Connection, template: Template, params: Record<string, any>): Promise<SendResult>;
getErrorHandler(errorCode: any): string;
}

interface ConnectionResult {
channelId: string;
accessToken: string;
expiresIn: number;
} 2. 프로바이더 어댑터 (Adapter)TypeScript// (예시: /providers/KakaoProvider.ts)
class KakaoProvider implements IProvider {
providerName = 'kakao';
async connect(...) { /_ 5. OAuth2 시퀀스 다이어그램 로직 _/ }
async send(...) { /_ 6. 코드 예시 (Node.js) 로직 _/ }
getErrorHandler(errorCode) { /_ 6. mapKakaoErrorToGuide 로직 _/ }
}

// (예시: /providers/NaverProvider.ts) - 확장 시
class NaverProvider implements IProvider {
providerName = 'naver';
// ... 네이버 OAuth 및 SENS API 로직 구현
} 3. 공통 스키마: Connections 테이블에 provider: 'kakao' | 'naver' | 'slack' 컬럼 추가.결정·근거·다음 단계:결정: 백엔드 로직을 IProvider 인터페이스 기반의 어댑터 패턴으로 설계합니다.근거: MVP에서는 KakaoProvider만 구현하되, 향후 NaverProvider 등을 추가할 때 API 엔드포인트 수정 없이 비즈니스 로직만 교체 가능합니다. [Report] (확장성 언급)다음 단계: BE 코드 구조 설계 시 /providers 디렉토리 생성 및 IProvider 인터페이스 정의.12. 로드맵·예산[Report]의 1~2주 MVP 타임라인 [Report, cite: 16]은 매우 낙관적이므로, 소규모 팀(3명) 기준 현실적 일정을 6주로 재산정합니다.Phase 1: 0 → 1 (MVP) (6주)Week 1-2: 준비 및 인증 [Report][Report]의 '준비 단계' + '인증 및 연동' [Report]Supabase/Vercel 설정, DB 스키마(RLS 포함) 적용 [Report, cite: 3, 15]Supabase Auth 및 카카오 OAuth (PKCE) 연동 완료 [Report]Week 3-4: 핵심 기능 (템플릿 & 전송)[Report]의 '템플릿 편집기' + '전송 테스트' [Report]템플릿 UI, JSON 생성, 미리보기 구현 [Report]BE: 메시지 API 연동 및 테스트 전송 기능 완료.Week 5: 안정화 (에러 & 로깅)[Report]의 '에러 진단 로직' [Report]에러 코드 매핑, 전송 로그 DB 저장 및 조회 UI 구현 [Report]Week 6: 배포 및 문서화[Report]의 'UI 완성·배포' [Report]최종 테스트(E2E), 개인정보 처리방침 게시, 사용자 가이드 작성 후 런칭.Phase 2: 1 → N (확장) (분기 단위)Q1: MVP 사용자 피드백 반영, '알림톡' 템플릿 심사 연동, 대시보드 고도화.Q2: 확장 전략(11) 기반 네이버 SENS 연동 (첫 번째 확장).Q3: 유료 플랜 (8) 도입, 팀 기능 (초대/권한) 개발.예산 (MVP 6주 기준)인건비: 3명 (기획1, FE1, BE1) x 1.5개월 = 4.5 M/M (확실치 않음: 인력 단가에 따라 변동)인프라비: (섹션 4 참조) 월 $45. (6주간 약 $70)결정·근거·다음 단계:결정: [Report]의 1-2주 [Report] 대신 6주를 MVP 개발 기간으로 설정합니다.근거: 1-2주는 RLS, OAuth PKCE, 토큰 암호화, 에러 처리 등 필수 보안/안정화 작업을 포함하기에 비현실적입니다. [Report, cite: 16]다음 단계: Week 1-2 일정 시작 (Supabase 설정 및 OAuth 연동).13. 근거·출처·버전본 계획서는 사용자가 제공한 AI·자동화 지원 웹앱 기획 및 개발 보고서.md (이하 [Report])를 기반으로 작성되었습니다.[Report]가 인용한 원본 출처는 다음과 같습니다:[1, 5, 6] Kakao Developers REST API (kakaotalk-message) [Report, cite: 1][2, 12] Supabase Architecture Docs [Report, cite: 2][3] Supabase Row Level Security Docs [Report, cite: 3][4] Kakao i Connect Message (Biz Message) OAuth 2.0 Docs [Report, cite: 4][7] Slack Developer Docs (OAuth) [Report, cite: 7][8] Google Forms API (Apps Script) Docs [Report, cite: 8][9] Kakao Developers Error Code Docs [Report, cite: 9][10, 15] Supabase with React Docs [Report, cite: 10][11] Vite Env Variables Docs [Report, cite: 11][13] Postman API Design Guide [Report, cite: 13][14] Treblle Blog (Express Structure) [Report, cite: 14][16] Netguru Blog (MVP Timeline) [Report, cite: 16]불확실성: [Report, cite: 4] (Biz Message OAuth)와 [Report, cite: 1, 5] (https://www.google.com/search?q=Kapi.kakao.com REST API) 간의 OAuth 흐름 및 토큰 공유 여부가 불명확합니다. 본 문서는 [Report]의 기술 스펙을 따라 https://www.google.com/search?q=Kapi.kakao.com 기반(Auth Code + PKCE)으로 설계했으나, 실제 Biz Message API 연동 시 별도 인증 체계 [Report, cite: 4]를 따라야 할 수 있습니다.16. Phase 분할 (본 계획서의 정의)Phase 1: 분석 (완료)산출물: 본 문서의 섹션 1, 2, 3, 8, 9, 10완료 기준: 요구사항, MVP 범위, 정책, 리스크 식별 완료.Phase 2: 설계 (완료)산출물: 본 문서의 섹션 4, 5, 6, 7, 11완료 기준: 기술 스택, 아키텍처, API, DB 스키마, 핵심 로직(OAuth, 템플릿) 설계 완료.Phase 3: 프로토타입 (실행)산출물: (섹션 12의 로드맵) 동작하는 MVP 소프트웨어.완료 기준: 6주 로드맵에 따른 기능 구현 및 내부 테스트 통과.Phase 4: 검증·출시 (실행)산출물: 런칭된 서비스, 사용자 가이드 문서, 운영 대시보드.완료 기준: 클로즈 베타 테스트 및 공개 런칭 완료, 핵심 지표(8) 측정 시작.🚀 최종 요약 및 다음 단계본 실행 계획은 Supabase와 React/Vite 스택을 기반으로 [Report], 비개발자가 카카오톡 메시지를 쉽게 연동·테스트하는 웹앱을 6주 내 MVP로 구축하는 것을 목표로 합니다. 핵심은 PKCE를 적용한 OAuth 2.0 보안 [Report]과 template_object JSON 편집기 [Report]이며, 초기 리스크는 카카오 정책 변경과 토큰 보안 사고로 식별되었습니다.
